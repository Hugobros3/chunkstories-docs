# Chunk Stories Graphics API

1. Declare a bunch of render buffers
2. Declare a bunch of shader passes (declare and inject dependencies) using those render buffers
	* Include hooks in passes so they can bind custom uniforms and textures
	* In the absence of geometry, a pass can be made a 'fs quad' pass, acting unifomrly accross the viewport
3. Declare how you want your content to be represented
	* Voxels are either cubes or a custom Representation
		- Voxel lightning will be done using corner light values bilinearly interpolated in the fragment shader
	* Representations are the general way to deal with supplying the renderer
		- Representations can be lights or models
		- Representation include a position and a target pass
	* Texture data is supplied as "Surfaces", containing albedo, normal and pbr maps
	* Representations can be attached to an entity or hooked manually
4. Configure built-in systems
	* Particles and decals can be made to be rendered in any pass you wish, in a per type fashion (and thus use your own shader variant)
	* Heightmaps rendering also offers you such control
	* You can decide to override the default deffered lightning pass
		- In the future provisions should be made to enable forward or forward+ rendering techniques
5. Write your GUI against the providen framework

## Shader Interfacing and meta-language

 * Mesh vertice attributes are bound to the corresponding vertex shader input, if any
 * Uniform data comes in interface blocks (only - no loose uniforms)
 * per-Instance data comes in interface blocks
 * Interface blocks can have Java wrappers autogenerated

## Implementation considerations

 * The implementations is expected to be API-independant : both OpenGL 3.3 and Vulkan are considered as targets
 * The bundling of the same models using instancing is expected to be a tremendous performance win, and the engine will be fully responsible of doing that
 * Skeletal matrices computations should be done hierachically when evaluating the representation. Morphed skeletal animation will be providen as instance data.
 * A GLSL->SPIR-V compiler will have to be included for the Vulkan backend

## Data flow

 1. Gather rendering tasks: Build a FrameGraph 
 2. gatherRepresentations() : fill a buckets of <out Representation::class, Representation>
	 * Ask each dispatching system to enumerate what it wants to draw
	 * foreach representation object type:
		 * cullable ? cull for every context camera and store it an bitmask
 3. dispatch representations
	 * foreach rendering context
	 	 * figure out the interested passes systems and submit them the representations (with the optional cull data bitmask)

example
```
ingamelayer.kt: call gather(RenderingContext(player.camera))

passes {
	sky
	gbuffers
	deferred shading // oh wait this calls render(sun.directionalLight)
	post
}

so becomes

passes {
	rendercontext = main {
	sky
	gbuffers
	deferred shading
		rendercontext = sun.shadow {
			shadowmap
		}
	post
	}
}
```

### Textures

VK_EXT_descriptor_indexing is the only true god. The GL/GLES implem will figure something out.

### Uniforms

Let uniforms be provided:
 * per-frame ( frame number, world time, animation time )
 * per-rendering-context ( camera stuff mostly )
 * per-system ( system-dependant stuff )
 * per-batch/draw ( frowned upon, use instance data instead )

### Per-instance data

Using structs too

### Camera/Rendering contexts

```kotlin
// camera for object culling
// bindings for shader passing
data class RenderingContext(val camera: Camera?, val bindings: Set<ShaderBinding>)
```

```kotlin
	renderFrame() {
		//...
		val mainCamera = client?.ingameClient?.player?.controlledEntity?.traits?.get(TraitPerspective::class)?.camera
		graphicsFrontend.present("finalPass", )
	}
```

```kotlin
// context is main camera
rendertask {
	name = "main"
	buffers {
		...
	}

	passes {
		pass {
			name = "resolveDeffered"

			hooks {
				hook {
					if(game.config.shadows) {
						val results = invokeRendertask("shadowDirectional")
						bindings.bindTexture()
					}
				}
			}
		}
	}

	finalPass = ...
}

rendertask shadowDirectional(light: DirectionalLight) : ShadowMap {

}

rendertask blurBuffer(renderBuffer: RenderBuffer, blurFactor: Float) {

}
```

### The idea of systems

 * Passes are just in/outputs
 * There are general (scheduling) systems, get subinstanced for every pass
 * 

### Naming stuff

 * Pass = A specific configuration of outputs ( output render targets configuration ), inputs (for knowledge necessary for layout transitions) and depth, along with dependencies for ordering.
 * GraphicalSystem = Something that will issue draw commands inside a pass
 * RenderBuffer = A buffer passes can use
 * RenderTask = A scoped sub-graph containing render buffers and passes. Can be called explicitely/dynamically
 * RenderingContext = An instance of a render task executing
 * FrameGraph = The final graph of every rendering context and pass to execute for a given frame

 * Representation = Generic interface exposed by anything that can be given to the rendering front-end
 * Mesh = .dae/.gltf model loaded from asset
	- Can include exported materials from the modelling software as default
 * Model = Instance of a mesh, possibly with a set of material overrides, InstanceData (and possibly animation data, maybe that's just one sort of InstanceData though ? )
 * Material = Named set of textures/values that define how geometry should be shaded
 * Matter ( from legay Material name usage ) = Generic template and classification for Blocks, representing a physical kind of matter/material as we conceptually see it ( glass, wood, rock etc )
 * Block = A named bag for holding everything that defines a certain block type